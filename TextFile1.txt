14.03.2025
ООП: Стандартная библиотека. Алгоритмы
Алгоритмы – обобщённые функции, реализующие типичные алгоритмы над элементами контейнера. Большинство алгоритмов принимают итераторы, задающие определённый диапазон элементов. Находятся в файлах <algorithm>.
Копирование элементов: std::copy(iterator start, iterator end, куда копировать)
std::copy(iterator begin, iterator end, iterator result)

std::copy(begin, end, std::ostream_iterator<int>(std::cout, ", ")) - копирование элементов из контейнера в стандартный поток вывода с разделителем ','
std::copy(begin, end, iterator where) - последний итератор - откуда начать копирование в контейнер
Если размер второго контейнера меньше количества вставляемых элементов - будет неопределённое поведение

std::copy(begin, end, std::front_insert(container)) - делает операцию push_front в переданный контейнер

Сортировка: std::sort
по умолчанию - сортирует по возрастанию
std::sort(begin, end, std::greater<T>()) - сортировка по убыванию
std::sort(begin, end, std::fuction<bool(const T&, const T&)>) - сортирующая функция
Для сортировки НЕОБХОДИМЫ итераторы произвольного доступа. Нельзя отсортировать map, т.к. ключи - константы и их расположение нельзя изменить

<ranges> - позволяет сортировать диапазоны
std::ranges::sort(container)
std::ranges::sort(container, std::function<bool(const T&, const T&)>)

Можно сортировать любые пользовательские типы данных, передавая лямбда функцию, которая возвращает true - если элементы упорядочены
std::ranges::sort(container, std::function<bool(const T&, constT&)>, &T::field) - последний параметр - проекция

Если у нескольких элементов будут совпадать, то их относительный порядок может измениться
std::ranges::stable_sort() - относительный порядок одинаковых элементов будет сохраняться

std::lower_bound - возвращает итератор на первый элемент >= искомому или на конечный элемент, если его нет
std::upper_bound - возвращает итератор на первый элемент, который > искомого или на конечный элемент, если его нет
std::equal_range - возвращает пару итераторов, первый от lower_bound, второй от upper_bound

Поиск в контейнере
std::find_if(begin, end, std::function<bool(const T&)>) - возвращает итератор на первый элемент для которого предикат = true
Если ничего не найдено, вернёт итератор, переданный вторым параметром

std::find(begin, end, value) - ищет элемент в переданном диапазоне.

std::any_of(begin, end, std::function<bool(const T&)>) - возвращает true если хотя бы 1 элемент удовлетворяет условию предиката
std::all_of() - все элементы должны соответствовать предикату 
std::none_of() - для всех элементов хотя бы для одного предикат вернёт false

std::nth_element() - найти элемент, который будет n-м по значению в отсортированном диапазоне

Идиома erase-remove (Идиома - выражение, которое специфичная для какого-то натурального языка)

std::remove(begin, end, value) - уберёт элементы в диапазоне, равные по значению value, остальные элементы перемещают
std::erase(begin, end) - удаляет элементы из переданного диапазона
С++ 20 - для вектора
std::erase, std::erase_if (std::vector<T>, std::function<bool(const T&)>) - удалит элементы из вектора

std::optional (since C++17) - опциональный элемент, который может содержать или не содержать элемент
Имеет операцию приведения к bool
Не использует динамическое выделение памяти
Применение: 
Отложенное конструирование элементов, объектов
Результат поиска
Проинформировать об ошибке
Неопределённое значение

nullopt - пустой optional
ostream& operator<<(ostream& strm, const T& val) - перегруженный оператор вывода в поток
Чтобы обратиться к элементу нужно использовать *optional
метод value() выбросит исключение если optional пустой

Работа с файловой системой
<filesystem> since C++17

Возможности:
Можно получить путь к временной папке
std::filesystem::path std::filesystem::current_path()
путь имеет перегруженный оператор вывода в поток
имеет метод string() который вернёт строку
generic_string() - вернёт путь разделённый /
parent_path() - путь к родительской папке
filename() - выведет путь от которого отрезан current_path()
можно склеивать пути с оператором /
объединит используя нативный для ОС слэш
stem() - имя без расширения
extension() - расширение без имени
replace_extention(std::string newExt) - замент расширение

filesystem::recursive_directory_iterator(currentPath) - вернёт диапазон содержащий все файлы и папки в переданном пути
