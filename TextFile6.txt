25.04.25
-Наследование
--Выраажет отношения "является" между классами
--Помогает повторному использованию кода
---Новый класс наследует данные и поведение базового класса
--Делает возможным модификацию и расширение
---Класс-потомок может добавить свои данные и методы в дополнение к функционалу базового класса

-Основные понятия
--Класс-родитель - класс, от которого наследуются другие классы
--Класс-потомок - класс, который унаследован от другого класса
--Базовый класс - не наследуется ни от кого, находится на вершине иерархии наследования (от него наследуются другие)
--Иерархия наследование - структура, отношение между классами, в простейшем случае - дерево
--Один базовый класс может иметь множество потомков
-Публичное наследование - когда один класс является частным случаем другого
-На диаграммах изображается в виде стрелки с незакрашенным треугольником. Стрелка
направлена от класса-потомка к классу-родителю

-Передача параметров конструктору родителя
--Можно вызвать конструктор класса-родителя через список инициализации конструктора класса-потомка.
--explicit A(B val) : C(val) {}
--Если конструктор класса-родителя совпадает по сигнатуре с конструкторам класса-потомка,
то возможна следующая запись:
class A {
public:
	explicit A(double val) : m_val(val) {}
	explicit A(int val) : m_val(val) {}
private:
	int m_val;
};
class B : A {
	using A::A // Будет B(int val) и B(double val)
};

-Приведение типа вверх по иерархии классов
--Публичное наследование выражает отношение "Является" ("is a")
--Это позволяет использовать экземпляры наследников, везде, где
ожидается ссылка или указатель на родительский класс. Ссылки на класс-потомок
могут неявно приводиться к ссылкам или указателям на класс-родитель

-Хранение данных класса-наследника в С++
--Класс наследник хранит в памяти сначала данные класса-родителя, а потом свои данные
--Поэтому функции и методы, которые принимают указатель или ссылку на класс-родитель
могут преобразовываться к любым наследникам этого класса

-Виртуальные методы, полиморфизм
--Если мы хотим, чтобы классы-наследники могли переопределять какой-то метод, то нужно добавить
ключевое слово virtual перед возвращаемым типом.
--Чтобы переопределить виртуальный метод, нужно написать ключевое слово override после
списка параметров метода
--Можно объявить приватный виртуальный метод, тогда классы наследники не смогут его вызвать,
но смогут переопределить.

-Полиморфизм - возможность работы с разными раеализациями через один и тот же интерфейс
--Полиморфизм времени выполнения
--Полиморфизм времени компиляции

-В С++ переопределяемый метод родительского класса должен быть объявлен виртуальным
--Компилятор будет знать, что метод может быть переопределён подклассами
--Объект с виртуальными методами хранит дополнительную информацию, позволяющую узнать
о типе объекта во время выполнения
--Хранит он эти данные в таблице виртуальных функций:
---Если объект имеет виртуальные методы, то в самом начале этого объекта
будет указатель на таблицу виртуальных функций
---Она хранит адреса всех виртуальных функций объекта
---Когда создаётся экземпляр класса-родителя, то компилятор подставляет указатель
на нужный тип
---Когда вызывается виртуальный метод, компилятор идёт в таблицу виртуальных функций объекта
и вызывает нужную функцию

-Итоги
--Объявляйте метод родителя виртуальным, если хотите, чтобы классы-наследники могли переопределить
его реализацию.
--Если не требуется переопределять метод в наследниках, не объявляйте его виртуальным, а в классах наследниках
не создавайте методов с такой же сигнатурой
--Виртуальный метод остаётся виртуальным в классах наследниках

-Защищённые данные и методы класса
--Когда классу-наследнику необходимо иметь доступ к полям класса-родителя,
но чтобы интерфейс класса не изменился
--Можно объявить друга, но тогда мы получим доступ ко ВСЕМ приватным полям и методам
--Лучше делать зашищёнными именно методы, а не поля.
--На диаграмме отображаются с префиксом #

-Зашищённый конструктор
--Доступен лишь классам-наследникам
--Код вне класса не может создать экземпляр класса напрямую

-Деструкторы и наследование
--Виртуальный деструктор
--Когда оператор delete удаляет класс-наследник через указатель на родительский класс,
деструктор класса-родителя должен быть объявлен виртуальным.
--Деструктор базового класса должен практически всегда должен быть публичным и виртуальным

-Публичный невиртуальный деструктор
--Генерируется компилятором по умолчанию
--Используются для:
---Классов без наследников
---Не удаляются полиморфно
---Используются не только как родительские классы, но и сами по себе
--Если в одном из классов-родителей был виртуальный деструктор, то деструктор наследника
тоже будет вируальным

-Публичный виртуальный деструктор нужно объявлять, если:
--У класса будут наследники
--Класс-наследник будет удаляться полиморфно

-Защищённый невиртуальный деструктор используется, если
--Не создаётся напрямую
--Не удаляется полиморфно
--Попытка вызвать такой деструктор вызовет ошибку компиляции
--Нужен, если мы не хотим, чтобы классы-наследники можно было удалять полиморфно

-std::variant - using Variant = std::variant<T1,T2,T3>;
--Может принимать любой переданный в шаблон тип.

-Финальные классы и методы
--Класс можно пометить ключевым словом final
--От такого класса нельзя унаследоваться
--Виртуальный метод можно объявить финальным, такой метод нельзя будет переопределить в подклассе
--Применение:
---Явно запретить наследовать классы и переопределять методы, не предназначенные для этого класса
---Компилятор может оптимизировать вызов виртуального метода, если знает, что метод не переопределяется в подклассе
это называется девиртуализацией