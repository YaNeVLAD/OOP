-Копирование объекта (копирующий конструктор)
-Вызывается при явном создании копии, неявном создании копии:
--Возвращение из функции, передача по значению
-T(const T& other)
--Copy elision - оптимизация компилятора, при которой копирование или перемещение объекта пропускается,
с c++ 17 - обязателен
--Вызывается при передаче временных объектов в функции по значению
--Можно удалить конструктор копирования с помощью T(const T& other) = delete;
-Идиома copy-and-swap - создаём копию объекта на стеке и обмениваем её поля с нашим объектом
-Минусы копирования: избыточное создание временных объектов, не все типы объектов можно копировать
-RValue ссылки - то что может стоять справа от знака присваивания (временные объекты, константы)
-LValue ссылки - то что может стоять слева от знака присваивания (созданные объекты)
-T&& - синтаксис
-Главное в симантике перемещения - std::move ничего не перемещает
-При перемещении значение временного объекта передаётся в создаваемый объект
-Временный объект передаёт создаваемому права владения своими ресурсами
-После перемещения объект должен остаться в некотором валидном состоянии, возможно, неизвестном.
--Это значит, что лучше не работать с перемещённым объектом.
-Для некоторых классов поведение после перемещения определено.
-Операция перемещения может быть реализована гораздо эффективнее, чем копирование
--Нет смысла писать перемещение, если оно эквивалентно копированию
-Правило 5 - Если вы перегрузили конструктор перемещения, копирования, перемещающий= или копирующий=, то вероятно
нужно переопределить остальные 4
--ВСЕГДА проверяем на самоперемещение, чтобы не разрушить данные объекта
-Делегирующий конструктор - конструктор, который не сам выполняет операцию, а делегирует Целевому конструктору
--В списке инициализации указано имя этого же класса, поля указывать нельзя
--Сначала выполнется целевой конструктор, потом выполнится целевой конструктор
--Оно помогает избежать дублирование кода
--Из-за copy elision - временные объекты также не перемещаются
--return value optimisation - при возвращении параметра по значению мы не копируем объект, а создаём по
переданному адресу в невидимый параметр.