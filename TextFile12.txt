30.05.25
-Специализация шаблона
--Полная специализация - все шаблонные параметры определены
--Частичная специализация - часть шаблонных параметров переопределена
--Специализация обозначается как <> перед началом функции или класса
template <>
ReturnType Foo<ConcreteType>(...) {...}

-Проверка шаблона. Substitution failure is not an error (SFINAE)
template <typename T>
struct IsIntegral
{
static inline const bool value = false;
}

template<typename T>
inline constexpr bool IsIntegralV = IsIntegral<T>::value;

struct IsIntegralTrue
{
static inline const bool value = true;
}

template<>
struct IsIntegral<unsigned> : IsIntegralTrue {};
struct IsIntegral<int> : IsIntegralTrue {};

--Условный оператор if с constexpr (С++17)
if constexpr (...) {...}
--Такое условие будет проверено во время компиляции, если условие
ложно, то блок условия не будет даже добавлен к компиляции

-Шаблонные методы класса
--Даже если класс не является шаблонным, у него могут быть шаблонные методы
--Можно объявлять внутри и снаружи класса

-Шаблоны и наследование
--Шаблоны можно спокойно использовать в иерархии наследования

-CRTP (Curiously Recurring Template Pattern)
--Класс наследник передаёт в класс родитель себя в качестве шаблонного параметра
--Это позволяет реализовать наследование без виртуальных функций, вызвав напрямую
реализацию метода у класса наследника из класса родителя
--Это позволяет реализовать полиморфизм времени компиляции
--static_cast<const Derived*>(this)->Method(...)
---Позволяет скастить себя к шаблонному наследнику

--Минусы
---Полиморфизма времени выполнения у таких классов не будет

-Миксин - класс, который добавляет определённую функциональность другому
классу через наследование
--В С++ это реализуется, как шаблонные классы, принимающие в качестве шаблонного
параметра класс наследник.
--Можно скомбинировать несколько миксинов через множественное наследование
--Помогают избежать дублирования кода
--Отличается от декоратора, тем, что интерфейс класса расширяется и реализуется
миксин через наследование, а декоратор через композицию или агрегацию

-Наследование шаблона от обычного класса
--Код, не зависящий от шаблонного параметра выносится в обычный родительский класс
--Это позволяет разделить код и уменьшить время компиляции

-Как избавиться от ромбовидного наследования через шаблоны
--Нужно создать абстрактный шаблонный класс, который будет публично наследоваться от
своего шаблонного параметра и реализовывать все его виртуальные методы.
--Это также позволяет устранить дублирование кода.

-Variadic templates (Шаблоны с переменным числом аргументов)
--std::tie - функция, которая принимает произвольное количество параметром и 
возвращает кортеж из ССЫЛОК на переданные параметры.
--Сравнение std::tuple происходит в лексико-графическом порядке
--Вариативный шаблон объявляется как template<typename... Types>
--Вариативный шаблон функции
template<typename... Types>
void Foo(Types... values) {...}
--Могут иметь размер от 0 до n, где n зависит от возможностей компилятора

-Операции с пачкой параметров
--Узнать размер пачки с помощью оператора sizeof...(Types...), на место этого
оператора при развёртке шаблона просто поставится количество переданных
шаблонных параметров
--Распаковка пакета параметров Types... values -> values...
--Можно в таком виде передавать в параметры функций

-Распаковка пакета типов
template<typename... Bases>
class Derived : publict Bases... {...};

-Обработка пакета параметров
--Иногда можно обойтись рекурсивным решением для обработки списка шаблонных
параметров
--Паттерн распаковки
---F(args...) // F(x, y, z);
---F(&args...) // F(&x, &y, &z);
---F(H(args)...) // F(H(x), H(y), H(z));
---F(const_cast<const Types*>(&args)...);