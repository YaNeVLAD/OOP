04.04.25
Модификаторы доступа
-public - интерфейс класса.
-private - реализация класса. Обработка данных, вспомогательная работа.
-protected - интерфейс для производных классов. Доступ разрешён для класса и его потомков. 
Данные не видны снаружи, но реализация которых может быть переопределена или использована
производными классами.
-Свойства - составляющая часть объекта, доступ к которой осуществляется программистом как к полю.
Могут быть доступны как для чтения, так и для записи. Отладчик может показывать и значения свойств.
getter'ы свойств не должны иметь побочных эффектов. В С++ нет свойств, вместо этого создаются getter и setter.

-Отличие методов от функции. Метод можно объявить внутри класса. Могут быть определены как внутри, так и снаружи.
Методы могут обращаться к приватным методам класса.
Методы могут быть виртуальными и чисто виртуальными.
При вызове метода нужно указывать ассоциированный объект.
-В метод класса первым невидимым параметром передаётся указатель на вызываемый объект. (T* const this, Args...)
-Если имя параметра совпадает с полем класса, то будет использоваться параметр.

-Инициализация класса
-Состояние экземпляра класса определяется значением его полей
-Поля делаются приватными, чтобы нельзя было нарушить инвариантность класса
-Вызов публичного метода переводит класс из одного валидного состояния в другое или не меняет его.
-После создания объект должен быть в валидном состоянии.
--Конструктор
--Специальная функция-член класса, которая нужна для инициализации объекта в момент его создания.
--Класс может иметь несколько конструкторов, чтобы инициализировать его по-разному.
---Конструктор по умолчанию (пустая строка, пустой вектор, точка в начале координат)
---Этот конструктор не имеет параметров, он инициализирует поля класса значениями по умолчанию
---Может неявно генерироваться компилятором
---Если у класса есть конструктор с параметрами, то компилятор не сгенерирует конструктор по умолчанию.
---Можно попросить сгененировать его T() = default;
--Список инициализации конструктора
---Поля класса инициализируются перед телом конструктора.
---Полезен, когда в качестве данных класса используются другие данные или если данные - константа или ссылка или у них
нет конструктора по умолчанию
---Можно передать параметры в конструтор родительского класса
--- T() : m_field(constructor), m_field2(), ...
---Порядок в списке инициализации не влияет на порядок инициализации полей класса. На него влияет порядок объявления в классе
---Это нужно, чтобы все поля для всех конструкторов вызывались в одном порядке (в порядке инициализации)
---А деструкторы вызываются в обратном порядке инициализации
---Инициализировать желательно в списке инициализации, т.к. это произойдёт до конструирования объекта
--Converting Constructor
---Конструктор, который не объявлен как explicit называется конвертирующим конструктором.
---Он нужен для того, чтобы компилятор неявно конструировал объекты при передаче в параметрах функции, например
---Может приводить к непясным ситуациям или конфликтам в объявлениях (наверное)
---Если конструктор имеет 1 параметр, то скорее всего его нужно пометить словом explicit, только если неявное
преобразование желательно
---Если конструктор имеет несколько параметров, то его почти неикогда не нужно помечать словом explicit
--Деинициализация экземпляра класса (деструктуризация) необходима, чтобы объект освободил ресурсы.
---При этом используемые единолично ресурсы должны освобождаться.
---В С++ для этого используется деструктор
---Объявляется как ~T()
---Деструктор вызывается автоматически при уничтожении экземпляра класса:
----Выход за пределы блока, в котором объявлен экземпляр класса
----Вызов оператора delete или delete[]
---В деструкторе обычно размещают код, выполняющий действия, завершающие цикл объекта.
---std::uninitialized_copy_n(T* from, size_t size, T* to) - копирует данные из инициализиуемой памяти в неинициализированную.
---std::destroy_n(T* block, size_t size) - вызывает деструкторы типов в переданном блоке
---В C++ после выполнения тела деструктора происходит автоматический вызов деструкторов членов-данных класса
---При наследовании класс был унаследован от другого класса, то деструкторы будут вызываться снизу вверх по иерархии
---Если мы хотим наследоваться от класса, то нужно деструктор объявлять виртуальным
--Автоматически сгенерированный деструктор
---Создаётся компилятором, если явно не объявлен деструктор
---Он имеет пустое тело
---Деструктор примитивных объектов не генерируется.
---Он не выполнит удаление C массива через new T[]