16.05.25
-Дружественные функции и классы
--Дружественная функция - не является членом класса, но имеет
доступ к его private и protected членам.
--Сама функция объявляется внутри класса с использованием ключевого слова
friend, а её реализация находится вне тела класса
--Используются для реализации внешних операций, тесно связанных с логикой класса

-Дружественный класс
--Класс, которому разрешён доступ к private и protected членам другого класса
--Дружба - односторонняя связь, если мы хотим подружить оба класса, в каждом
нужно объявить друга, используя forward declaration

-Перегрузка операций
--Позвоялет задать естественное поведение опператоров для пользовательских типов данных
--Принципы хорошего стиля:
---Поведение оператора должно быть интуитивно ожидаемым
---Перегрузка не должна нарушать семантику оператора

--Виды перегрузок оператора:
---В виде оператора - члена класса
----Хорошо подходит когда левый операнд - сам объект класса
----Хорошо работает для =,+=,-=,++,-- и д.р.
----Не подходит для операций, где левый операнд - не объект класса
---Оператор объявлен вне класса
----Используется когда надо обеспечить симметрию или левый операнд
не является объектом класса
----Даёт гибкость и симметрию
----Нет доступа к приватным членам класса
---В виде дружественной операции
----Внешняя функция, имеющая доступ к приватным членам класса
----Симметрия + доступ к приватным данным класса
----Зависит от реализации класса

--Нельзя перегрузить:
--- ::, ., ?:, sizeof, typeid, alignof, noexcept, placement new
--- Нельзя перегрузить арность операций
--- Нельзя изменить приоритет и ассоциативность операций

-Перегрузка арифметических операций
--Бинарные операции одного типа лучше перегружать вне класса, чтобы
обеспечить симметричность (возможно как friend)

-Перегрузка присваивающих операций
--Операции +=, -=, *=, /= модифицируют лувый аргумент и возвращают ссылку на него
--Обычно перегружаются внутри класса
--Часто на их основе перегружаются операции +,-,*,/
class T
{
	T& operator+=(const T& other)
	{
		// change current state
		return *this;
	}
};

T operator+(T lhs, const T& rhs)
{
	return lhs += rhs;
}

-Перегрузка операций сравнения
--Не модифицируют состояния сравниваемых объектов
--Возвращают операции типа bool
--Обычно перегружают вне класса
--Начиная с С++ 20 можно не реализовывать операцию !=, если реализована операция ==
--Начиная с С++ 20 появился оператор spaceship, очень полезен, если
сравнение сводится к простому покомпонентному сравнению
auto operator<=>(const T&) const = default
--Можно реализовать следующим образом: (класс дробей)
std::strong_ordering operator<=>(const Rational& rhs) const 
{
	retrun (m_num * rhs.m_denom) <=> (rhs.m_num * m_denom);
}
--Если вручную переопределить оператор <=>, то операции == и !=
автоматически сгенерированы не будут

-Разные типы порядка
--Не все типы можно сравнить одинаково
---У некоторых строгий порядок (int, std::string)
---У других равенство может быть нестрогим (NaN != NaN)
---У некоторых равенство отличается от идентичности (std::string_view)

--std::strong_ordering - между значениями есть отношение строгого порядка (std::string)
---less, greater, equivalent, equal
---Эквивалентные значения не различимы

--std::weak_ordering - слабый, но устойчивый порядок. Равенство означает (std::string_view)
эквивалентность, но не идентичность
---less, equivalent, greater
---Эквивалентные значения различимы

--std::partial_ordering - частичный порядок (числа с плавающей запятой)
---Используется, когда не все элементы можно сравнить
---less, equivalent, greater, unordered
---Эквивалентные значения различимы и есть несравнимые значения

-Перегрузка унарного плюса и минуса
T operator+() const {}
T operator-() const {}

-Перегрузка операторов ввода-вывода в поток
--В SLT операции ввода-вывода выполняются при помощи потоков данных
--Всегда перегружаются вне класса
--Возвращают ссылку на переданный поток, чтобы можно было чейнить вызовы
--Хорошо обрабатывать ошибки так: stream.setstate(std::ios::failbit | stream.rdstate());

-Умный указатель
--Класс, обычно шаблонный, имитируюший интерфейс обычного указателя и добавлящий новую
функциональность
---Перегрузка операций * и ->, специфичных для простых указателей
--SLT содержит умные указатели std::unique_ptr, std::shared_ptr, std::weak_ptr
--Первый имеет единоличное владение переданным ресурсом
--Второй подсчитывает количество ссылок на объект и последний удаляет объект
--Третий не продлевает жизнь объекту, увеличивает количество слабых ссылок

-Проблема встроенных типов
--Один и тот же тип (int, float, std::string) можно использовать для разных
вещей и случайно сложить килограммы с деньгами

-Решение - создать шаблонный класс Tagged
--std::pair<int, double> и std::pair<int, std::string> - разные типы
--Первый шаблонный параметр - тип хранимого значения
--Тип маркера, чтобы отличать один тип от другого

template<typename T, typename Tag
class Tagged
{
	// перегрузка Tagged(T&&), Tagged(const T&)
	// операции ->, *
	// оператор <=>
	// операция вывода в поток
}

Потом
struct UserTag {}
using Id = Tagged<std::string, UserTag>;
//В С++20 можно так: Tagged<std::string, decltype([]{})>

-User-defined literals
--Облегчают создание объектов, путём создания указывания суффикса после значения
-- 10u, 10.f

--Есть стандартные литералы
---Объявлены в std::literals
--- ""s, ""sv, 125ms, 18.5i

--Можно определить свои литералы
---Суффик должен начинаться с подчёркивания

--Синтаксис
long doulbe ""_deg_to_rad(long double deg)
{
	return // calc radians
}

T operator""_T(const char* cStr, std::size_t len) {...}

--Многократный вызов функций

class Repeater
{
	Repeater(std::size_t repeatCount) : m_repeatCount(repeatCount) {}

	template<class T>
	void Do(T fn) {...} // repeats given function m_repeatCount times
private:
	std::size_t m_repeatCount;
}

Repeater operator""_Times(std::size_t count)
{
	return Repeater(count);
}

5_Times.Do([]{ std::cout << "Hello World!"; });