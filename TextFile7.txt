02.05.25
-Виды наследования в С++
--Варианты наследования
---По типу доступа к членам базового класса
----Публичное наследование - публичные и приватные методы сохраняют свой уровень доступа
----Защищённое наследование - публичные и приватные методы становятся защищёнными 
----Приватное наследование - публичные и приватные методы становятся приватными

--Публичное наследование (открытое) - выражает отношения is a, сохраняется
интерфейс базового класса. Это называется наследованием типа, наследованием интерфейса
и позволяет реализовывать полиморфизм. Везде где ожидаются ссылки или указатели базового класса
можно использовать производные. Такой код должен корректно работать без знания о производных классах.
---Если производный класс не полностью поддерживает функционал базового класса, то публичное наследование
будет ошибкой проектирования. Или такое наследование нарушает логику производного класса (массив и стек)

--Закрытое (приватное) наследование
---Все публичные и защищённые поля и методы становятся приватными.
---Также называется наследованием реализации.
---Когда мы хотим использовать реализацию родительского класса.
---Производный класс не является подтипом базового.
---Выражает отношения "Реализован на основе".

--Композиция - предпочтительная альтернатива приватному наследованию.
---Если можно использовать композицию, лучше использовать композицию
---В композируемом классе могут быть несколько экземпляров существующего класса,
что делает его более гибким.
---Композиция снижает зависимость классов друг от друга, в отличие от наследования,
которое тесно связывает классы.
---Приватное наследование может быть более подходящим, например, если нам требуется
доступ к защищённым методам родительского класса.
---С точки зрения интерфейса нового класса - композиция и наследование одинаковы.

--Защищённое наследование
---Наследование реализации, доступной для последующего наследования.
---Порождённый класс может использовать эти члены, но должен предоставить собственный
публичный интерфейс.
---Производные классы не являются подтипами базового.
---Приведение типов возможно только внутри самого класса.
---Позволяет скрыть реализацию, но сделать её доступной для наследников производного класса.

--Вызов конструкторов и деструкторов при наследовании
---При конструировании сначала будет вызван конструктор базового класса, при чём до
инициализации производного класса.
---После конструктора базового класса вызываются конструкторы членов класса.
---Конструктор производного класса может явно вызвать конструктор родителя через
список инициализации.
---Порядок вызова деструкторов противоположен порядку вызова конструкторов.
---Сначал вызовется деструктор производного класса, затем деструкторы членов класса,
затем деструктор базового класса.

--Особенности работы виртуальных методов в конструкторе и деструкторе
---Во время работы конструктора объект ещё полностью не сконструирован
----Обращаться к полям класса-наследника нельзя, пока они не сконструированы.
---Во время работы конструктора или деструктора виртуальные методы работают
как обычные, т.е. будет вызвана реализация родительского класса.
---Лучше не вызывать виртуальные методы в конструкторе и деструкторе.

--Абстрактные классы
---Родительский класс может представлять абстрактное понятие и служить каркасом
для производных классов
---В нём могут быть методы, не имеющие универсальной реализации
----Например, как вычислить площадь или нарисовать объект.
---Такие методы объявляются чисто виртуальными, к ним добавляется инициализатор = 0
---Если в классе есть хотя бы 1 чисто виртуальная класса или мы унаследовались
и не реализовали хотя бы одну чисто виртуальную функцию, такой класс считается
абстрактным и его экземпляр нельзя создать.
---Это обязывает классы-наследники реализовывать такие методы

--Интерфейс
---Предельный случай абстрактного класса, у него все методы чисто виртуальные
и класс не содержит никаких данных.
---Интерфейс задаёт набор методов, которые должны быть у его наследников, чтобы
с ними можно было взаимодействовать.
---Описывает протокол взаимодействия с объектом. Реализация интерфейса означает
соответствие этому протоколу.
---Интерфейс - способ описать обязательный набор операций, которые должен
поддерживать объект.
---Классы называются взаимозаменяемыми, если они реализую один интерфейс.
---На диаграмме отображаются точно также как и наследование, только
стрелочка пунктирная.
---Интерфейсы применяются для описания контрактов, которые обязуется выполнить
любой класс, реализующий данный интерфейс.
---Интерфейс не может использовать ни композицию, ни агрегацию. От него может
только что-то зависить. Один интерфейс может наследоваться от другого интерфейса.

--Достоинства интерфейсов:
---Устранят зависимость от конкретных реализаций
---Повышают гибкость архитектуры
---Упрощают тестирование
---Позволяют применять Принцип Инверсии Зависимостей и программироваию через интерфейсы
---Позволяет разорвать циклические зависимости путём выделения интерфейса для одного
из зависимых классов

--Приведение типов вверх и вниз по иерархии классов
---Всегда можно привести вверх по иерархии классов
---Иногда можно привести вниз по иерархии классов
---Никогда нельзя привести между несвязными иерархиями

--Оператор static_cast можно безопасно ИСПОЛЬЗОВАТЬ только при приведении вверх по иерархии.
--Для других случаев нужно использовать dynamic_cast для безопасного приведения типа во время
выполнения программы.
--Можно использовать для приведения указателей (при неудаче вернётся nullptr)
--Можно использовать для приведения ссылок (при неудаче выбросит исключение std::bad_cast)
--Требует наличия хотя бы одного виртуального метода в базовом класса 
(для поддержки RTTI - Run-Time Type Information)
--Лучше использовать для ссылок как
void A(R& ref)
{
	T* t = dynamic_cast<T*>(&ref);
}

--Не злоупотребляйте dynamic_cast
---Код оказывается жёстко привязанным к конкретным типам
---Наруется принцип открытости-закрытости: при добавлении нового класса
придётся менять существующий код
---Снижается производительность (выполняется во время выполнения и требует поддержки RTTI)

--Предпочтительнее использовать виртуальные функции:
---Не нужно вручную определять тип объекта
---Работает быстрее

--Зачем он нужен
---Нет возможности сделать метод виртуальным, например, если базовый класс находится
в сторонней библиотеке. Тогда можно привести ссылку или указатель к конкретному классу
оператором dynamic_cast и вызвать нужную операцию
---Зная один интерфейс объекта, нужно запросить у него другой.