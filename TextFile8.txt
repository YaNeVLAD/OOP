07.05.25
-Множественное наследование
--Когда наследование происходит от нескольких базовых классов
--При множественном наследовании производный класс объединяет
реализации всех своих родительских классов
--Может быть полезно для реализации нескольких интерфейсов или
при повторном использовании функциональности из разных иерархий

-Ромбовидное наследование
--Называется так из-за формы иерархий
--Если пойти по разным веткам, всё равно придём к 1 базовому классу
--Возникает тогда, когда родители производного класса имеют общего предка
--Это даёт следующую проблему: производный класс будет иметь неоднозначного
предка
--Можно вызывать методы базовых классов как
class R : public T {};
R obj;
obj.T::Method();
--Чтобы избежать это, нужно использовать виртуальное наследование
--Нужно, чтобы оба родителя производного класса виртуально
наследовались от общего базового класса:
class T : public virtual R, public virtual S {};

-Ограничения виртуального наследования:
--Классы предки не могут одновременно переопределять одни и те же методы своего родителя

-Множественное наследование может быть полезным
--Можно создавать классы, сочетающие поведение нескольких реализаций
--Реализовывать несколько интерфейсов в одном классе
--Избегайте ромбовидного наследования, если вам явно оно не нужно

-Преимущества использования наследования
--Расширять функционал существующих классов
---Унаследовать состояние и/или поведение базового класса
---Устраняет необходимость дублирования кода
--Полиморфизм
---Возможность использовать общий интерфейс для работы с различными реализациями
---Упрощает добавление новых типов без изменения существующего кода
--Инкапсуляция различий
---Разные реализации одного интерфейса скрываются за единым типом
---Заменяет условные конструкции вызовами виртуальных функций
--Унификация API
---Можно писать код, не зная конкретного типа объекта, а лишь его базовый интерфейс

-Наследование и вопросы проектирования
--Сильная связь между классами
---Наследование - вторая по силе форма связи после дружбы
---Подразумевает тесную зависимость от базового класса
--Контракт с базовым классов
---Класс наследник обязуется следовать интерфейсу и ожиданиям базового класса
---Нарушение контракта может привести к ошибкам проектирования или нарушению инвариантов
--Хрупкость иерархий
---Изменения в базовом классе могут непредсказуемо повлиять на производные классы
---Критично в больших проектах и при работе с чужим кодом
--Избегайте глубоких иерархий наследования
---Многоуровневое наследование затрудняет понимание, тестирование и сопровождение
---Предпочтительны композиция, агрегация.

-Runtime-полиморфизм с std::variant
--Появился в c++ 17 и может хранить внутри себя объект один из заранее переданных типов
using Animal = std::variant<Cat, Cow, Dog>;
--Альтернатива классическому решению с использованием наследования
--Позволяет реализовать полиморфное поведение через визиторы
--Хорошо сочетается с современным стилем программирования на с++
--std::monostate - замена void для std::variant (Пустая структура)

-Как получить доступ к содержимому
--Использовать std::visit - обхект с перегруженным оператором для всех типов std::variant
--std::visit(visitor, variant_value);

using A = std::variant<T, R, S>;
struct Printer
{
	void operator(T) const 
	{
	}
	void operator(R) const 
	{
	}
	void operator(S) const 
	{
	}

}
--Нужно перегружить operator() для ВСЕХ возможных типов std::visitor, иначе
код просто не скомпилируется.
--Чтобы добавить новую операцию - нужно создать новый класс-посетитель

using A = std::variant<T, R, S>;
struct MaxPrinter
{
	void operator(T) const 
	{
	}
	void operator(R) const 
	{
	}
	void operator(S) const 
	{
	}

}
--Универсальная лямбда-функция: [...](auto value, ...) {...}.
Эта функция принимает параметром auto
--std::holds_alternative<T>(std::variant<...>) - проверка типа в variant
--std::get<T>(std::variant<...>) - получить значение из варианта.
Если не проверить, выкидывает std_bad_variant_access.
--std::get_if<T>(std::variant<...>) - вернёт или указатель на переданный
тип
--Можно использовать overloaded pattern
template<class T...>
struct overloaded : T...
{
	using T::operator()...;
};

//explicit deduction_guide (не требуется, начиная с С++ 20)
template<class T...>
overloaded(T...) -> overloaded<T...>;

using Number = std::variant<int, double>;
void Print(Number n)
{
	std::visit(
	overloaded{
		[](int i) {...},
		[](double d){...},
	}, n);
}

--Можно посетить несколько std::variant, передав в лямбду и/или std::visit несколько
параметров.
--Можно использовать вот так:
void operator(auto A, auto B) { (*this)(B, A); }
-- Это позволит не обрабатывать дублирующиеся случаи, когда это не нужно

-Достоинства std::variant
--Не использует динамическое выделение памяти
---Объекты создаются на стеке
--Легко добавить новые операции, зависящие от типа объекта
---Создаётся новый visitor
--Нет базового класса
---Может работать с несвязанными типами
--Можно использовать примитивные типы данных
--При небольшом количестве типов visit может работать быстрее виртуальных методов

-Недостатки std::variant
--Все типы внутри std::variant должны быть известны на этапе компиляции
---В программах, поддерживающих плагины, не получится добавить новый тип
--Сложно добавлять новые типы
---Требуется модификация всех поситителей
--Возможно неэффективное использование памяти
---std::variant резервирует место под самый большой тип
--Для каждой новой операции нужно добавлять новый посетитель
---Без должного контроля они моут быть разбросаны по разным файлам
--Передача аргументов более громоздкая
---Параметры операций хранятся в полях посетителя
--Может проигрывать виртуальным методам по производительности
---При большом числе типов std::visit может стать узким местом