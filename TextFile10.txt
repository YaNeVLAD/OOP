23.05.25
-Перегрузка оператора []
--Унарный оператор, принимает индекс любого типа
--Используется для доступа к элементам контейнера
--Имеет форму для чтения и для записи
--Возвращает ссылку на элемент
--Может быть объявлен только внутри класса

-Почему возвращаем константную ссылку?
--Потому что у значения можно взять адрес и по нему определить расположение
символов в строке
--Если взять адресс у константной ссылки, вернётся адресс временной переменной

-В С++23 оператор[] может принимать несколько индексов
--До С++23 решением было использование прокси-объекта

-std::conditional_t<Condition, IfTrueType, ElseType> - вернёт тип в зависимости
от истинности первого шаблонного параметра

-Перегрузка инкремента и декремента
--Полезно перегружать для итераторов и счётчиков
--Эти операторы являются унарными операциями
--Префиксны и постфиксные операторы имеют разную сигнатуру
и перегружаются по-разному

--Префиксная форма возвращает ссылку на изменённый объект, не имеет аргументов
--Постфиксная форма возвращает временную копию объекта до модификации, принимает int
--Префиксная форма реализуется через постфиксную форму

-std::add_lvalue_reference_t<T>, std::add_pointer_t<T> - полезные вспомогательные типы из type_traits

-Операторы инкремент и декремент можно перегрузить вне класса
--Можно добавить для не вашего типа

-Перегрузка оператора приведения типа
--Иногда возникает необходимость выполнить приведение одного
пользовательского типа к другому (не обязательно пользовательскому)
--operator Type()[const]
--Может быть explicit, чтобы убрать неявное приведение типов, без
использования static_cast
--Если operator bool объявить как explicit, то его можно будет
без явного приведения использовать в условных конструкциях, но в других
случаях явно не получится привести

-Оператор приведения типов нужно перегружать аккуратно, т.к.
его можно заабьюзить

-Перегрузка оператора (). Функциональные объекты
--Функциональным объектом называется объект, с перегруженным оператором ()
--Преимущества перед функциями
---Наличие состояния
---Объект функции обладает некоторомы типом и может выступать в качестве
спецификации шаблона

-Почему нужно писать typename после T::R - если мы ссылаемя на тип