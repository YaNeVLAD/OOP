15.05.25
-Подзапросы и CTE
--Подзапрос - это SQL запрос, используемый внутри другого SQL-зарпоса для получения одного значения,
списка значений или входной таблицы.
--Виды подзапросов:
---Табличные:
----Таблица
----Список (таблица из одной колонки)
---Скалярные (возвращает только 1 значение)
--Синтаксис такой же как у обычных запросов, только оборачиваются в ()

--Где использовать:
---Таблица - JOIN, FROM
---Список - IN, NOT IN
---Скалярный - вместо выражений

--Коррелированный подзапрос - запрос, который ссылается на колонки
или выражения из внешнего запроса.

-CTE (Common Table Expressions)
--CTE - именованные подзапросы, объявленные в секции WITH
--Синтаксис WITH <table_name> AS (<sub_query>)

-Рекурсивные CTE
--Синтаксис WITH RECURSIVE <table_name> (<atribute_name>, ...) AS
(
	# initialization block (порядок инициализации в таком же порядке, как названия атрибутов)
	SELECT <atribute_value>,...

	UNION ALL

	# recursive block
	SELECT <recursibe_step>, <value> FROM <table_name> 
	# recursive stop condition
	WHERE <condition> - while loop
	# or
	LIMIT <iterations> - for loop
)

-Представления (VIEW)
--Это виртуальные таблицы, содержимое которых выбирается SQL-запросом из других таблиц
--Это SQL запрос, сохранённый в переменную

--VIEW позволяет сделать:
---Удобное представление данных других таблиц
---Разграничение доступа на уровне базы данных

--Недостатки VIEW
---Медленнее аналогичной физической таблицы
---Сложнее в понимании
---Сложнее в сопровождении

--Из представления также можно удалять значения
--Представление просто вставляет подзапрос на место своего названия

--Синтаксис CREATE OR REPLACE VIEW <view_name>
... # same syntax as SELECT

-Переменные сессии
--Живут всё время соединения
--Если создать строковую переменную можно указать кодировку COLLATE

-Создание функций и процедур
--Синтаксис 
CREATE FUNCTION <func_name>(<param_name>,...) # или ()
	RETURNS CHAR(2)
	NOT DETERMINISTIC # Детерминированные функции всегда возвращают один результат при определённым наборе параметров
BEGIN
	DECLARE <variable_name> <variable_type> DEFAULT <default_value>

	# if-else construction
	RETURN IF(@value IN <list>, <on_true>, <on_false>)
	# if 
END;

--Преимущества хранимых функций
---Переиспользование SQL фрагментов
---Хорошо для выражений, сложных в понимании и используемых повсеместно

--Недостатки хранимых функций
---Ограниченный язык (SQL - не язык программирования)
---Трудно сопровождать

-Триггер - хранимая функция, вызываемая при срабатывании события
--События INSERT, UPDATE, DELETE
--Синтаксис
CREATE TRIGGER <trigger_name>
BEFORE/AFTER <INSERT,UPDATE,DELETE>
ON <table_name>
FOR EACH ROW # для каждой записи
BEGIN
	# Может использовать ключевое слово OLD для обращения к предыдущим значениям записей
	...
END;

--Недостатки триггеров
---Триггер - это всегда неожиданность для разработчика
---Неожиданные ограничения СУБД
----В MySQL триггеры не работают при ON DELETE CASCADE / ON UPDATE CASCADE
